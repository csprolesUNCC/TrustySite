<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Draw Trusty! - Trusty da Horse</title>
<link rel="apple-touch-icon" sizes="180x180" href="/images/mobile-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/images/icon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/images/icon-16x16.png">
<link rel="stylesheet" href="/styles/stylesheet.css">
<script> window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); }; </script>
<script defer src="/_vercel/insights/script.js"></script>
<style>
    .content {
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    
    canvas {
        background:white;
        border: 3px solid #111; 
        box-shadow: 6px 6px 0px 0px #111;
        touch-action:none;
    }
    button {
        margin-top:15px;
        padding:10px 20px;
        font-size:18px;
        cursor:pointer;
        border: 2px solid #111;
        background-color: #ffe08d;
        font-weight: bold;
        box-shadow: 3px 3px 0px 0px #555;
        border-radius: 0;
        transition: all 0.1s;
    }
    button:active {
        box-shadow: 1px 1px 0px 0px #555;
        transform: translate(2px, 2px);
    }
    #scoreBox {
        margin-top:15px;
        font-size:26px;
        font-weight:bold;
    }
    #buttonContainer {
        display: flex;
        justify-content: center; 
        gap: 10px;            
        margin-top: 15px;
    }
    #gameCanvas + div {
        font-size: 22px;
        font-weight: bold;
        margin-top: 10px;
    }

    #leaderboard-container {
        width: 500px;
        margin-top: 30px;
        padding: 15px;
        border: 3px solid #111;
        background-color: #ffe08d;
        box-shadow: 6px 6px 0px 0px #111;
        text-align: left;
    }
    
    #leaderboard-container h3 {
        margin-top: 0;
        border-bottom: 2px solid #111;
        padding-bottom: 5px;
        text-align: center;
    }

    #leaderboard-container ol {
        list-style-type: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 5px;
    }
    
    #leaderboard-container li {
        font-size: 1.1em;
        display: flex;
        justify-content: space-between;
        padding: 5px 10px;
        background-color: #fff9e6;
        border: 1px solid #111;
        border-radius: 4px;
    }

    .leaderboard-entry {
        display: flex;
        align-items: center;
        justify-content: space-between;
        width: 100%;
    }

    .leaderboard-info {
        display: flex;
        align-items: center;
        gap: 15px;
    }

    .user-drawing-thumb {
        width: 50px;
        height: 50px;
        border: 1px solid #111;
        background: white;
        object-fit: contain;
    }

    /* trying to fix mobile view here! */
    @media (max-width: 850px) {
    canvas {
        max-width: 100%;
        height: auto;
    }

    #leaderboard-container,
    #daily-leaderboard-container {
        max-width: 100%;
        width: 800px;
        box-sizing: border-box;
    }
    }
    /* trying to fix mobile view here! */
</style>
</head>
<body>

    <header>
        <div id="click-game-placeholder"></div>
        <h1>Draw Trusty!</h1>
        <div id="auth-component-placeholder">
            </div>
    </header>

    <nav id="navbar-placeholder"></nav>

    <div class="content">
        <h2>Memorize and Draw!</h2>
        
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        <div id="scoreBox"></div>
        <div id="buttonContainer">
            <button id="finishBtn">DONE</button>
            <button id="restartBtn">RESTART</button>
        </div>

        <div id="leaderboard-container">
            <h3>ðŸŽ¨ Master Artists Loading...</h3>
        </div>
    </div>


    <footer><p id="footer-placeholder"></p></footer>
    
    <script src="/scripts/componentLoader.js"></script>
    <script src="/scripts/loginHandler.js"></script>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const finishButton = document.getElementById("finishBtn");
const restartButton = document.getElementById("restartBtn");
const scoreBox = document.getElementById("scoreBox");
const leaderboardContainer = document.getElementById("leaderboard-container");

let drawing = false;
let gameFinished = false;
let lastX = 0, lastY = 0;
let drawingEnabled = false;
let timerInterval = null;
let startTimeout = null;
const timerDisplay = document.createElement("div");
timerDisplay.style.fontSize = "22px";
timerDisplay.style.fontWeight = "bold";
timerDisplay.style.marginTop = "10px";
canvas.parentNode.insertBefore(timerDisplay, canvas.nextSibling);

let highScore = 0;
let leaderboard = [];
let isUserLoggedIn = localStorage.getItem('isUserLoggedIn') === 'true';

// ---- Draw stick figure reference ----
function drawReference(ctxToDraw) {
    const ctxUse = ctxToDraw;
    ctxUse.strokeStyle = "black";

    ctxUse.beginPath();
    ctxUse.ellipse(100, 180, 75, 75 * 1.25, 0, 0, Math.PI * 2);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.ellipse(100, 220, 28, 25 * 1.25, 0, -Math.PI/20, Math.PI + Math.PI/20);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(80, 130); ctxUse.lineTo(80, 180); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(120, 130); ctxUse.lineTo(120, 180); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(100, 275); ctxUse.lineTo(150, 340); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(150, 340); ctxUse.lineTo(425, 340); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(150, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(250, 445); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(300, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(400, 445); ctxUse.stroke();
}

// ---- Player drawing ----
ctx.lineWidth = 5;
ctx.strokeStyle = "black";
ctx.lineCap = "round";

function startDraw(x, y) { if(!drawingEnabled) return; drawing = true; lastX = x; lastY = y; }
function draw(x, y) { if(!drawing || !drawingEnabled) return; ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y;}
function stopDraw() { drawing=false; }
function getTouchPos(e) {
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    return {
        x: (touch.clientX - rect.left) * scaleX,
        y: (touch.clientY - rect.top) * scaleY
    };
}

canvas.addEventListener("mousedown", e => startDraw(e.offsetX, e.offsetY));
canvas.addEventListener("mousemove", e => draw(e.offsetX, e.offsetY));
canvas.addEventListener("mouseup", stopDraw);
canvas.addEventListener("mouseenter", e => { lastX = e.offsetX; lastY = e.offsetY; });

canvas.addEventListener("touchstart", e => { 
    e.preventDefault(); // Prevents scrolling while drawing
    const pos = getTouchPos(e);
    startDraw(pos.x, pos.y); 
});
canvas.addEventListener("touchmove", e => { 
    e.preventDefault(); 
    const pos = getTouchPos(e);
    draw(pos.x, pos.y); 
});
canvas.addEventListener("touchend", stopDraw);

let hitData, expectData, closeData, zoneData;

function gradeDrawing() {
    if (!drawingEnabled && !gameFinished) return;
    if (gameFinished) return;

    resetGameState();
    gameFinished = true;

    drawingEnabled = false;
    timerDisplay.style.display = "none";
    clearInterval(timerInterval);

    const width = canvas.width;
    const height = canvas.height;

    const userImgData = ctx.getImageData(0, 0, width, height).data;

    const perfectCanvas = getGhostCanvas(6);
    const perfectCtx = perfectCanvas.getContext('2d');
    const perfectImgData = perfectCtx.getImageData(0, 0, width, height).data;
    
    const ghostCanvas = getGhostCanvas(25);
    const ghostCtx = ghostCanvas.getContext('2d');
    const ghostImgData = ghostCtx.getImageData(0, 0, width, height).data;

    const ghostCanvas2 = getGhostCanvas(50);
    const ghostCtx2 = ghostCanvas2.getContext('2d');
    const ghostImgData2 = ghostCtx2.getImageData(0, 0, width, height).data;

    const ghostCanvas3 = getGhostCanvas(70);
    const ghostCtx3 = ghostCanvas3.getContext('2d');
    const ghostImgData3 = ghostCtx3.getImageData(0, 0, width, height).data;

    const ghostCanvas4 = getGhostCanvas(140);
    const ghostCtx4 = ghostCanvas4.getContext('2d');
    const ghostImgData4 = ghostCtx4.getImageData(0, 0, width, height).data;



    let overlapCount = 0;
    let totalUserPixels = 0;

    let perfectUserPixels = 0;
    let totalRefPixels = 0

    const radius = 5;

    for (let i = 0; i < userImgData.length; i += 4) {
        
        const userAlpha = userImgData[i + 3];
        const perfectAlpha = perfectImgData[i + 3];
        const ghostAlpha = ghostImgData[i + 3];
        const ghostAlpha2 = ghostImgData2[i + 3];
        const ghostAlpha3 = ghostImgData3[i + 3];
        const ghostAlpha4 = ghostImgData4[i + 3];

        // completeness logic
        if (perfectAlpha > 50) {
            totalRefPixels++;
            let matched = false;

            const pixelIndex = i / 4;
            const x = pixelIndex % width;
            const y = Math.floor(pixelIndex / width);

            for (let dx = -radius; dx <= radius && !matched; dx++) {
                for (let dy = -radius; dy <= radius; dy++) {

                    const nx = x + dx;
                    const ny = y + dy;

                    if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;

                    const ni = (ny * width + nx) * 4;
                    if (userImgData[ni + 3] > 50) {
                        perfectUserPixels++;
                        matched = true;
                        break;
                    }
                }
            }

        }

        // precision logic
        if (userAlpha > 100) {
            totalUserPixels++;
            if (perfectAlpha > 50) {
                overlapCount=overlapCount+1.05;
            }
            else if (ghostAlpha > 50) {
                overlapCount=overlapCount+0.9; 
            }
            else if (ghostAlpha2 > 50) {
                overlapCount=overlapCount+0.8; 
            }
            else if (ghostAlpha3 > 50) {
                overlapCount=overlapCount+0.7;
            }
            else if (ghostAlpha4 > 50) {
                overlapCount=overlapCount+0.5;
            }
            else{
                overlapCount=overlapCount-1.5;
            }
        }
    }





    // --- CALCULATE SCORE ---
    let precision = 0;
    if (totalUserPixels > 0) {
        precision = (overlapCount / totalUserPixels);
    }
    if (precision > 1) precision = 1;

    let completeness = 0;
    if (totalRefPixels > 0) {
        completeness = (perfectUserPixels / totalRefPixels);
    }
    if (completeness > 1) completeness = 1;

    let finalScoreRaw = (precision * 0.5) + (completeness * 0.5);

    let inkRatio = 0;
    if (totalRefPixels > 0) {
        inkRatio = totalUserPixels / totalRefPixels;
    }

    const maxAllowedRatio = 1.3; 
    let thicknessPenalty = 1.0; 

    if (inkRatio > maxAllowedRatio) {
        thicknessPenalty = maxAllowedRatio / inkRatio;
    }

    finalScoreRaw = finalScoreRaw * thicknessPenalty;
    let finalScore = Math.floor(finalScoreRaw * 100);

    if (finalScore < 0) finalScore = 0;
    const msg = finalScore === 100 ? "ðŸŽ‰ PERFECT!" : "";

    let highScoreMsg = "";
    if (isUserLoggedIn) {
        if (finalScore > highScore) {
            submitScore(finalScore);
            highScore = finalScore;
            highScoreMsg = ` (New Personal Best!)`;
        } else {
            highScoreMsg = ` (High: ${highScore}%)`;
        }
    } else {
        highScoreMsg = " (Log in to save!)";
    }

    scoreBox.textContent = `Score: ${finalScore}%${msg}${highScoreMsg}`;

    // --- SHOW FINAL REFERENCE LINE ---
    ctx.globalCompositeOperation = 'destination-over';
    ctx.strokeStyle = '#90EE90';
    ctx.lineWidth = 6;
    drawReference(ctx);
    ctx.globalCompositeOperation = 'source-over';
}

function resetGameState() {
    gameFinished = false;
    if (timerInterval) clearInterval(timerInterval);
    if (startTimeout) clearTimeout(startTimeout);
    timerInterval = null;
    startTimeout = null;
    drawingEnabled = false;
}

function startGame() {
    resetGameState();
    timerDisplay.style.display = "block"; 
    timerDisplay.textContent = "Memorize Trusty!";
    scoreBox.textContent = "";
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.lineWidth = 6; 
    ctx.strokeStyle = '#000000';
    drawReference(ctx);

    startTimeout = setTimeout(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        ctx.lineWidth = 5;
        ctx.strokeStyle = "black";
        ctx.lineCap = "round";

        drawingEnabled = true;
        timerDisplay.style.display = "block"; 
        let timeLeft = 25;
        timerDisplay.textContent = `Time left: ${timeLeft}s`;

        timerInterval = setInterval(() => {
            timeLeft--;
            timerDisplay.textContent = `Time left: ${timeLeft}s`;
            if (timeLeft <= 0) {
                gradeDrawing();
            }
        }, 1000);

    }, 2000);
}


finishButton.addEventListener("click", gradeDrawing);
restartButton.addEventListener("click", startGame);


// making grading layers
function getGhostCanvas(lineWidth) {
    const canvas = document.createElement('canvas');
    canvas.width = 500;
    canvas.height = 500;
    const ctx = canvas.getContext('2d');

    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = "black";
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    // -- Head --
    ctx.beginPath();
    ctx.ellipse(100, 180, 75, 75 * 1.25, 0, 0, Math.PI * 2);
    ctx.stroke();

    // -- Mouth --
    ctx.beginPath();
    ctx.ellipse(100, 220, 28, 25 * 1.25, 0, -Math.PI/20, Math.PI + Math.PI/20);
    ctx.stroke();

    // -- Eyes --
    ctx.beginPath();
    ctx.moveTo(80, 130); ctx.lineTo(80, 180);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(120, 130); ctx.lineTo(120, 180);
    ctx.stroke();

    // -- Neck/Body connector --
    ctx.beginPath();
    ctx.moveTo(100, 275); ctx.lineTo(150, 340);
    ctx.stroke();

    // -- Long Back --
    ctx.beginPath();
    ctx.moveTo(150, 340); ctx.lineTo(425, 340);
    ctx.stroke();

    // -- Front Legs --
    ctx.beginPath();
    ctx.moveTo(200, 345); ctx.lineTo(150, 445);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(200, 345); ctx.lineTo(250, 445);
    ctx.stroke();

    // -- Back Legs --
    ctx.beginPath();
    ctx.moveTo(350, 345); ctx.lineTo(300, 445);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(350, 345); ctx.lineTo(400, 445);
    ctx.stroke();

    return canvas;
}

//nLeaderboard & API Functions
async function fetchLeaderboard() {
    try {
        const response = await fetch('/api/draw-api?action=get_leaderboard'); 
        if (!response.ok) throw new Error('Failed to fetch leaderboard');
        leaderboard = await response.json();
    } catch (error) {
        console.error("Error fetching leaderboard:", error);
        leaderboard = []; 
    }
    drawLeaderboard(); 
}

async function submitScore(finalScore) {
    if (!isUserLoggedIn) return;

    const imageData = canvas.toDataURL("image/png");

    try {
        const response = await fetch('/api/draw-api?action=submit', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ 
                score: finalScore,
                image: imageData // This sends the drawing data
            })
        });

        if (response.ok) {
            console.log('Score submitted successfully! Refreshing...');
            await fetchPersonalHighScore();
            await fetchLeaderboard();
        } else {
            console.error('Score submission failed.');
        }
    } catch (error) {
        console.error("Error submitting score:", error);
    }
}

async function fetchPersonalHighScore() {
    if (!isUserLoggedIn) {
        highScore = 0;
        return;
    }

    try {
        const response = await fetch('/api/draw-api?action=get_personal'); 
        if (!response.ok) throw new Error('Failed to fetch user high score');
        const data = await response.json();
        highScore = data.highScore || 0; 
    } catch (error) {
        console.error("Error fetching personal high score:", error);
        highScore = 0; 
    }
}

function drawLeaderboard() {
    let html = '<h3>ðŸŽ¨ Master Artists ðŸŽ¨</h3><ol>';
    
    if (leaderboard.length === 0) {
        html += '<p style="text-align:center;">No drawings ranked yet!</p>';
    } else {
        leaderboard.slice(0, 10).forEach((entry, index) => { 
            const drawingImg = entry.drawing 
                ? `<img src="${entry.drawing}" class="user-drawing-thumb" alt="${entry.name}'s drawing">` 
                : `<div class="user-drawing-thumb" style="display:flex;align-items:center;justify-content:center;font-size:10px;">N/A</div>`;

            html += `
                <li>
                    <div class="leaderboard-entry">
                        <div class="leaderboard-info">
                            <span>**#${index + 1}**</span>
                            ${drawingImg}
                            <span>${entry.name.substring(0, 15)}</span>
                        </div>
                        <span>**${entry.score}%**</span>
                    </div>
                </li>
            `;
        });
    }
    
    html += '</ol>';
    leaderboardContainer.innerHTML = html;
}

fetchLeaderboard();
fetchPersonalHighScore();
startGame();
</script>
</body>
</html>
