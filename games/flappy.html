<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Trusty - Trusty da Horse</title>
    <meta name="description" content="Flappy Trusty: Test your patience with this retro arcade physics game! How far can Trusty the Horse fly through the deadly pipes?">
    <link rel="apple-touch-icon" sizes="180x180" href="../images/mobile-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../images/icon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../images/icon-16x16.png">
    <link rel="stylesheet" href="../styles/stylesheet.css">
    <script> window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); }; </script>
    <script defer src="/_vercel/insights/script.js"></script>
    <style>
        /* Specific overrides for the Flappy Horse page */
        body {
            /* Override the dark background set in the original flappy.html,
               but ensure the main body background from stylesheet.css is used */
            background: #f0f0f0; /* Default body background from stylesheet.css */
            display: block; /* Change display from flex to block for standard layout */
            height: auto;
            min-height: 100vh; /* Ensure full viewport height */
        }

        /* Center the canvas within the content area */
        .content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        canvas {
            border: 3px solid #111;
            background: #70c5ce;
            box-shadow: 6px 6px 0px 0px #111;
            margin-top: 20px;
        }

        /* NEW: Styles for the Leaderboard Container */
        #leaderboard-container {
            width: 800px; /* Match canvas width */
            margin-top: 30px;
            padding: 15px;
            border: 3px solid #111;
            background-color: #ffe08d; /* Light, contrasting background */
            box-shadow: 6px 6px 0px 0px #111;
            text-align: left; /* Align text within the container */
        }
        
        #leaderboard-container h3 {
            margin-top: 0;
            border-bottom: 2px solid #111;
            padding-bottom: 5px;
            text-align: center;
        }

        #leaderboard-container ol {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #leaderboard-container li {
            font-size: 1.1em;
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            background-color: #fff9e6;
            border: 1px solid #111;
            border-radius: 4px;
        }

        /* NEW: Styles for the Daily Leaderboard Container */
        #daily-leaderboard-container {
            width: 800px; /* Match canvas width */
            margin-top: 15px; /* Reduced margin */
            padding: 15px;
            border: 3px solid #111;
            background-color: #ffd9d9; /* Light, contrasting background (e.g., light red/pink) */
            box-shadow: 6px 6px 0px 0px #111;
            text-align: left;
        }
        
        /* Apply existing styles to the new container's children */
        #daily-leaderboard-container h3 {
            margin-top: 0;
            border-bottom: 2px solid #111;
            padding-bottom: 5px;
            text-align: center;
        }

        #daily-leaderboard-container ol {
            list-style-type: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        #daily-leaderboard-container li {
            font-size: 1.1em;
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            background-color: #ffffff; /* White list item background */
            border: 1px solid #111;
            border-radius: 4px;
        }
    </style>
</head>

<body>
    <header>
        <h1>Flappy Trusty</h1>
        <div id="auth-component-placeholder">
            </div>
    </header>

    <nav id="navbar-placeholder"></nav>

    <div class="content">
        <h2>Can Trusty Fly? (No)</h2>
        <p>A classic test of patience and physics! Click or press any key to flap your way through the deadly pipes.</p>

        <canvas id="gameCanvas" width="800" height="600"></canvas>
    
        <div id="leaderboard-container">
            <h3>Leaderboard Loading...</h3>
        </div>
    </div>

    <footer><p id="footer-placeholder"></p></footer>
    
    <script src="../scripts/componentLoader.js"></script>
    <script src="/scripts/loginHandler.js"></script>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const leaderboardContainer = document.getElementById("leaderboard-container");

        // Horse image
        const trustyImg = new Image();
        trustyImg.src = "../images/trusty.png";

        // sound effect
        const jumpSound = new Audio("../sound/vineboom.m4a"); 
        const horseSound = new Audio("../sound/horse.m4a"); 
        //jumpSound.volume = 0.4; 

        // Player
        let horse = {
            x: 80,
            y: 250,
            width: null, // placeholder, updated when image loads
            height: null,
            velocity: -3
        };

        let imageLoaded = false;

        trustyImg.onload = () => {
            horse.width = trustyImg.width / 16;
            horse.height = trustyImg.height / 16;
            imageLoaded = true;
        };

        const gravity = 0.4;
        const jumpStrength = -8;

        let gameOver = false;

        // Pipes
        let pipes = [];
        const pipeGap = 250;
        const pipeWidth = 65;
        let frame = 0;
        let pipeTimer = 0;
        let lastTime = 0;
        let leaderboard = [];
        let dailyLeaderboard = [];
        // Jump event
        let justTapped = false;
        let score = 0;
        let highScore = 0; // This will now hold the *personal* high score
        let isUserLoggedIn = localStorage.getItem('isUserLoggedIn') === 'true'; // NEW: Check login status
        let previousScore = 0; // Track score change for game over logic

        document.addEventListener("touchstart", e => {
            e.preventDefault();
            justTapped = true;
            jump();
        }, { passive: false });

        document.addEventListener("mousedown", () => {
            if (justTapped) return;
            jump();
        });

        document.addEventListener("keydown", jump);

        // --- Leaderboard Functions ---

        // 1. Fetch scores from the API
        async function fetchLeaderboard() {
            try {
                // NOTE: Use the full URL (e.g., https://your-site.vercel.app/api/get-scores) 
                // if running locally or not deployed on Vercel yet.
                const response = await fetch('../api/get-scores'); 
                if (!response.ok) throw new Error('Failed to fetch leaderboard');
                leaderboard = await response.json();
            } catch (error) {
                console.error("Error fetching leaderboard:", error);
                leaderboard = []; // Clear on failure
            }
            drawLeaderboard(); // Draw the leaderboard after fetching
        }

        // 2. Submit score to the API
        async function submitScore(finalScore) {
    if (!isUserLoggedIn) {
        console.log("Not logged in. Score not submitted.");
        return;
    }

    try {
        const response = await fetch('../api/submit-score', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ score: finalScore })
        });

        if (response.ok) {
            console.log('Score submitted successfully! Refreshing high score...');
            
            // --- CRITICAL FIX: Ensure the high score is updated immediately ---
            // Await both fetches to guarantee the client variable is current.
            await fetchPersonalHighScore(); // This updates the global 'highScore' variable
            await fetchLeaderboard(); // Refresh the global leaderboard

            // Now, console.log the *new* high score for verification
            console.log(`Updated Personal High Score is now: ${highScore}`); 

        } else {
            console.error('Score submission failed. Server said:', await response.json());
        }
    } catch (error) {
        console.error("Error submitting score:", error);
    }
}

        // 3. Fetch user's personal high score - NEW FUNCTION
        async function fetchPersonalHighScore() {
        if (!isUserLoggedIn) {
            highScore = 0; // Reset to 0 if logged out
            return;
        }

        try {
            const response = await fetch('../api/get-user-highscore'); 
            if (!response.ok) throw new Error('Failed to fetch user high score');
            const data = await response.json();
            // Update the global highScore variable
            highScore = data.highScore; 
            console.log('Personal High Score fetched:', highScore);
        } catch (error) {
            console.error("Error fetching personal high score:", error);
            highScore = 0; // Default to 0 on failure
        }
    }

        // 3. Draw leaderboard (to the HTML element)
        function drawLeaderboard() {
            let html = '<h3>üèÜ Trusty\'s Top Flaps üèÜ</h3><ol>';
            
            if (leaderboard.length === 0) {
                html += '<p style="text-align:center;">No scores yet! Be the first.</p>';
            } else {
                leaderboard.slice(0, 10).forEach((entry, index) => { // Show top 10
                    // Display name and score
                    html += `
                        <li>
                            <span>**#${index + 1}** ${entry.name.substring(0, 15)}</span>
                            <span>**${entry.score}**</span>
                        </li>
                    `;
                });
            }
            
            html += '</ol>';
            leaderboardContainer.innerHTML = html;
        }

        // --- Game Logic ---

        function jump() {
            if (!gameOver) {
                horse.velocity = jumpStrength;
                jumpSound.currentTime = 0;
                jumpSound.play();
            } else {
                resetGame();
            }
        }


        function checkLeaderboard() {
    if (gameOver && score > 0) {
        if (!isUserLoggedIn) {
            console.log("Game Over. User not logged in, score not saved.");
            return;
        }

        // The high score check is crucial here:
        if (score > highScore) {
            console.log(`New personal high score! Submitting ${score}. (Previous high: ${highScore})`);
            submitScore(score);
        } else {
            // but after the fix, it should be accurate.
            console.log(`Score ${score} did not beat personal high score ${highScore}.`);
        }
    }
}





        function resetGame() {
            trustyImg.src = "../images/trusty.png";

            horse.y = 250;
            horse.velocity = -3;
            pipes = [];
            score = 0;
            frame = 0;
            gameOver = false;
        }

        // Create pipes
        function createPipe() {
            let topHeight = Math.floor(Math.random() * 250) + 50;
            let bottomY = topHeight + pipeGap;

            pipes.push({
                x: canvas.width,
                topHeight: topHeight,
                bottomY: bottomY
            });
        }

        function drawHorse() {
            if (imageLoaded) {
                ctx.drawImage(trustyImg, horse.x, horse.y, horse.width, horse.height);
            } else {
                // fallback rectangle
                ctx.fillStyle = "red";
                ctx.fillRect(horse.x, horse.y, horse.width, horse.height);
            }
        }

        function drawPipes() {
            ctx.fillStyle = "green";
            pipes.forEach(pipe => {
                ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight); // top pipe
                ctx.fillRect(pipe.x, pipe.bottomY, pipeWidth, canvas.height - pipe.bottomY); // bottom pipe
            });
        }


        function checkCollision() {
            pipes.forEach(pipe => {
                let withinPipeX = horse.x + horse.width > pipe.x && horse.x < pipe.x + pipeWidth;
                let hitsTop = horse.y < pipe.topHeight;
                let hitsBottom = horse.y + horse.height > pipe.bottomY;

                if (withinPipeX && (hitsTop || hitsBottom)) {
                    gameOver = true;
                }
            });
        }

        function loop(timestamp){
            justTapped = false;
            if (!lastTime) lastTime = timestamp;
            const delta = (timestamp - lastTime) / 16.666; // normalize to 60 FPS
            lastTime = timestamp;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!gameOver) {
                frame++;
                horse.velocity += gravity * delta;
                horse.y += horse.velocity * delta;
                const floorY = canvas.height - horse.height;
                // Check for floor collision
                if (horse.y > floorY) {
                    horse.y = floorY;
                    horse.velocity = 0;
                }
                
                pipeTimer += delta;
                if (pipeTimer > 60) {
                    createPipe();
                    pipeTimer = 0;
                }

                pipes.forEach(pipe => pipe.x -= 4 * delta);

                // Remove off-screen pipes
                if (pipes.length && pipes[0].x < -pipeWidth) {
                    pipes.shift();
                    score++;
                    if (score == 10){
                        trustyImg.src = "../images/detailed_horse.jpg";
                        horseSound.play();
                    }
                }
                previousScore = score; 
            } else if (gameOver && previousScore > 0) {
                // Only trigger the high score check once when game over state is hit
                checkLeaderboard(); 
                previousScore = 0; // Reset to prevent re-triggering
            }


            drawHorse();
            drawPipes();
            checkCollision();
            
            // --- Score Display (High Score remains on canvas) ---
            
            // Score
            ctx.fillStyle = "white";
            ctx.font = "30px Arial";
            ctx.fillText(score, 20, 40);

            // High Score
            ctx.fillStyle = "yellow";
            ctx.font = "25px Arial";
            if (isUserLoggedIn) {
                ctx.fillText("High: " + highScore, 20, 70);
            } else {
                ctx.fillText("Log in to save score!", 20, 70);
            }

            // NOTE: drawLeaderboard() is now called only after fetching data, not in the loop.

            if (gameOver) {
                // Draw a semi-transparent overlay to make the text stand out
                ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = "white";
                ctx.font = "40px Arial Black";
                ctx.fillText("Game Over", 300, 300);
                ctx.font = "20px Arial Black";
                ctx.fillText("Press any key or click to restart", 263, 340);
            }

            requestAnimationFrame(loop);
        }

        // Fetch leaderboard immediately when the script runs
        fetchLeaderboard(); 
        fetchPersonalHighScore(); // NEW: Fetch personal high score on load
        requestAnimationFrame(loop);

    </script>

</body>
</html>