<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Stick Figure Grading Game</title>
<style>
    body { 
        background:#f0f0f0; 
        display:flex; 
        flex-direction:column; 
        align-items:center; 
        font-family:Arial, sans-serif;
    }
    canvas {
        background:white;
        border:4px solid black;
        box-shadow:6px 6px 0px #222;
        touch-action:none; /* critical for mobile drawing input */
    }
    button {
        margin-top:15px;
        padding:10px 20px;
        font-size:18px;
        cursor:pointer;
    }
    #scoreBox {
        margin-top:15px;
        font-size:26px;
        font-weight:bold;
    }
    #buttonContainer {
        display: flex;
        justify-content: center; /* center under canvas */
        gap: 10px;               /* space between buttons */
        margin-top: 15px;
    }
</style>
</head>
<body>

<h1>Draw Trusty!</h1>
<canvas id="gameCanvas" width="500" height="500"></canvas>
<div id="scoreBox"></div>
<div id="buttonContainer">
    <button id="finishBtn">DONE</button>
    <button id="restartBtn">RESTART</button>
</div>


<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const finishButton = document.getElementById("finishBtn");
const restartButton = document.getElementById("restartBtn");
const scoreBox = document.getElementById("scoreBox");

let drawing = false;
let lastX = 0, lastY = 0;
let drawingEnabled = false; // prevent drawing until preview ends
let timerInterval = null;
const timerDisplay = document.createElement("div");
timerDisplay.style.fontSize = "22px";
timerDisplay.style.fontWeight = "bold";
timerDisplay.style.marginTop = "10px";
canvas.parentNode.insertBefore(timerDisplay, canvas.nextSibling);

// ---- Draw stick figure reference ----
function drawReference(ctxToDraw) {
    const ctxUse = ctxToDraw;
    ctxUse.strokeStyle = "black";
    ctxUse.lineWidth = 6;

    ctxUse.beginPath();
    ctxUse.ellipse(100, 180, 75, 75 * 1.25, 0, 0, Math.PI * 2);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.ellipse(100, 220, 28, 25 * 1.25, 0, -Math.PI/20, Math.PI + Math.PI/20);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(80, 130); ctxUse.lineTo(80, 180); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(120, 130); ctxUse.lineTo(120, 180); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(100, 275); ctxUse.lineTo(150, 340); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(150, 340); ctxUse.lineTo(425, 340); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(150, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(250, 445); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(300, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(400, 445); ctxUse.stroke();
}

// ---- Player drawing ----
ctx.lineWidth = 5;
ctx.strokeStyle = "black";
ctx.lineCap = "round";

function startDraw(x, y) { if(!drawingEnabled) return; drawing = true; lastX = x; lastY = y; }
function draw(x, y) { if(!drawing || !drawingEnabled) return; ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y;}
function stopDraw() { drawing=false; }

canvas.addEventListener("mousedown", e => startDraw(e.offsetX, e.offsetY));
canvas.addEventListener("mousemove", e => draw(e.offsetX, e.offsetY));
canvas.addEventListener("mouseup", stopDraw);
canvas.addEventListener("mouseenter", e => { lastX = e.offsetX; lastY = e.offsetY; });

canvas.addEventListener("touchstart", e => { const r = canvas.getBoundingClientRect(); const t = e.touches[0]; startDraw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchmove", e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); const t = e.touches[0]; draw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchend", stopDraw);

let hitData, expectData, zoneData;

// ---- Grade drawing ----
function gradeDrawing() {
    drawingEnabled = false;
    timerDisplay.style.display = "none";
    clearInterval(timerInterval);

    const playerPixels = ctx.getImageData(0,0,canvas.width,canvas.height).data;
    let matchedPixels = 0, expectedRefPixels = 0, strayPixels = 0, totalPlayerPixels = 0;

    for(let i=3;i<expectData.length;i+=4) if(expectData[i]>100) expectedRefPixels++;
    for(let i=3;i<hitData.length;i+=4){
        const isHitbox=hitData[i]>0, isZone=zoneData[i]>0, isPlayer=playerPixels[i]>0;
        if(isPlayer){ totalPlayerPixels++; if(isHitbox) matchedPixels++; else if(!isZone) strayPixels++; }
    }

    if(expectedRefPixels===0) expectedRefPixels=1;
    if(totalPlayerPixels===0) totalPlayerPixels=1;

    let coverage = Math.min((matchedPixels/expectedRefPixels)*1.35,1.0);
    let accuracy = 1.0;
    const strayRatio = strayPixels/totalPlayerPixels;
    if(strayRatio>0.05) accuracy = Math.max(1.0-(strayRatio-0.05),0);
    let scoreRaw = (coverage*0.75)+(accuracy*0.25);
    if(totalPlayerPixels<50) scoreRaw=0;
    let score = Math.round(scoreRaw*100);
    let msg = score>=95?"ðŸŽ‰ PERFECT!":score>=80?"ðŸ’ª Very good!":score>=60?"ðŸ™‚ Not bad!":"ðŸ˜… Keep trying!";
    scoreBox.textContent = `Score: ${score}% â€” ${msg}`;

    ctx.globalCompositeOperation='destination-over';
    ctx.strokeStyle='#90EE90'; ctx.lineWidth=6;
    drawReference(ctx);
    ctx.globalCompositeOperation='source-over';
}

// ---- Start game ----
function startGame() {
    if(timerInterval) clearInterval(timerInterval);
    timerDisplay.textContent="";
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawingEnabled = false;

    // HITBOX
    const hitCanvas=document.createElement("canvas");
    hitCanvas.width=canvas.width; hitCanvas.height=canvas.height;
    const hitCtx=hitCanvas.getContext("2d"); hitCtx.lineWidth=28; hitCtx.lineCap="round"; drawReference(hitCtx); hitData=hitCtx.getImageData(0,0,canvas.width,canvas.height).data;

    // EXPECT
    const expectCanvas=document.createElement("canvas");
    expectCanvas.width=canvas.width; expectCanvas.height=canvas.height;
    const expectCtx=expectCanvas.getContext("2d"); expectCtx.lineWidth=8; expectCtx.lineCap="round"; drawReference(expectCtx); expectData=expectCtx.getImageData(0,0,canvas.width,canvas.height).data;

    // SAFE ZONE
    const zoneCanvas=document.createElement("canvas");
    zoneCanvas.width=canvas.width; zoneCanvas.height=canvas.height;
    const zoneCtx=zoneCanvas.getContext("2d"); zoneCtx.lineWidth=50; zoneCtx.lineCap="round"; drawReference(zoneCtx); zoneData=zoneCtx.getImageData(0,0,canvas.width,canvas.height).data;

    ctx.lineWidth=6; drawReference(ctx);

    setTimeout(()=>{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawingEnabled = true;
        timerDisplay.style.display = "block"; // show timer
        let timeLeft = 25;
        timerDisplay.textContent = `Time left: ${timeLeft}s`;

        timerInterval=setInterval(()=>{
            timeLeft--;
            timerDisplay.textContent=`Time left: ${timeLeft}s`;
            if(timeLeft<=0){
                clearInterval(timerInterval);
                gradeDrawing();
            }
        },1000);

    },2000);

    const newBtn=finishButton.cloneNode(true);
    finishButton.parentNode.replaceChild(newBtn,finishButton);
    newBtn.addEventListener("click",gradeDrawing);
}

// ---- Restart ----
restartButton.addEventListener("click", ()=>{
    if(timerInterval) clearInterval(timerInterval);
    scoreBox.textContent="";
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawReference(ctx);
    setTimeout(()=>{ startGame(); },2000);
});

startGame();
</script>
</body>
</html>
