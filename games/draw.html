<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Stick Figure Grading Game</title>
<style>
    body { 
        background:#f0f0f0; 
        display:flex; 
        flex-direction:column; 
        align-items:center; 
        font-family:Arial, sans-serif;
    }
    canvas {
        background:white;
        border:4px solid black;
        box-shadow:6px 6px 0px #222;
        touch-action:none; /* critical for mobile drawing input */
    }
    button {
        margin-top:15px;
        padding:10px 20px;
        font-size:18px;
        cursor:pointer;
    }
    #scoreBox {
        margin-top:15px;
        font-size:26px;
        font-weight:bold;
    }
    #buttonContainer {
        display: flex;
        justify-content: center; /* center under canvas */
        gap: 10px;               /* space between buttons */
        margin-top: 15px;
    }
</style>
</head>
<body>

<h1>Draw Trusty!</h1>
<canvas id="gameCanvas" width="500" height="500"></canvas>
<div id="scoreBox"></div>
<div id="buttonContainer">
    <button id="finishBtn">DONE</button>
    <button id="restartBtn">RESTART</button>
</div>


<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const finishButton = document.getElementById("finishBtn");
const restartButton = document.getElementById("restartBtn");
const scoreBox = document.getElementById("scoreBox");

let drawing = false;
let lastX = 0, lastY = 0;
let drawingEnabled = false; // prevent drawing until preview ends
let timerInterval = null;
const timerDisplay = document.createElement("div");
timerDisplay.style.fontSize = "22px";
timerDisplay.style.fontWeight = "bold";
timerDisplay.style.marginTop = "10px";
canvas.parentNode.insertBefore(timerDisplay, canvas.nextSibling);

// ---- Draw stick figure reference ----
function drawReference(ctxToDraw) {
    const ctxUse = ctxToDraw;
    ctxUse.strokeStyle = "black";
    ctxUse.lineWidth = 6;

    ctxUse.beginPath();
    ctxUse.ellipse(100, 180, 75, 75 * 1.25, 0, 0, Math.PI * 2);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.ellipse(100, 220, 28, 25 * 1.25, 0, -Math.PI/20, Math.PI + Math.PI/20);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(80, 130); ctxUse.lineTo(80, 180); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(120, 130); ctxUse.lineTo(120, 180); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(100, 275); ctxUse.lineTo(150, 340); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(150, 340); ctxUse.lineTo(425, 340); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(150, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(250, 445); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(300, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(400, 445); ctxUse.stroke();
}

// ---- Player drawing ----
ctx.lineWidth = 5;
ctx.strokeStyle = "black";
ctx.lineCap = "round";

function startDraw(x, y) { if(!drawingEnabled) return; drawing = true; lastX = x; lastY = y; }
function draw(x, y) { if(!drawing || !drawingEnabled) return; ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y;}
function stopDraw() { drawing=false; }

canvas.addEventListener("mousedown", e => startDraw(e.offsetX, e.offsetY));
canvas.addEventListener("mousemove", e => draw(e.offsetX, e.offsetY));
canvas.addEventListener("mouseup", stopDraw);
canvas.addEventListener("mouseenter", e => { lastX = e.offsetX; lastY = e.offsetY; });

canvas.addEventListener("touchstart", e => { const r = canvas.getBoundingClientRect(); const t = e.touches[0]; startDraw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchmove", e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); const t = e.touches[0]; draw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchend", stopDraw);

// Global variables for hit detection
let hitData, expectData, zoneData;

// 1. THE GENEROUS GRADING FUNCTION
function gradeDrawing() {
    drawingEnabled = false;
    timerDisplay.style.display = "none";
    clearInterval(timerInterval);

    const playerPixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

    let matchedScore = 0;       // Points for accuracy
    let validPlayerPixels = 0;  // Number of pixels that hit ANY target
    let totalRefPixels = 0;     // Total pixels in the reference image
    let strayPixels = 0;        // Pixels completely outside

    // Count reference pixels (The denominator)
    for (let i = 3; i < expectData.length; i += 4) {
        if (expectData[i] > 100) totalRefPixels++;
    }

    // Evaluate player pixels
    let totalPlayerInk = 0;
    for (let i = 3; i < playerPixels.length; i += 4) {
        if (playerPixels[i] < 10) continue; // Skip transparent pixels
        
        totalPlayerInk++;

        const near  = expectData[i] > 100; // Precision
        const close = hitData[i] > 0;      // Forgiving
        const safe  = zoneData[i] > 0;     // Way off but valid

        if (near) {
            matchedScore += 1.0;
            validPlayerPixels++;
        } else if (close) {
            matchedScore += 0.8;  // Generous points (was 0.7)
            validPlayerPixels++;
        } else if (safe) {
            matchedScore += 0.5;  // Generous points (was 0.45)
            validPlayerPixels++;
        } else {
            strayPixels++;
        }
    }

    // Safety Math (Prevent divide by zero)
    totalRefPixels = Math.max(totalRefPixels, 1);
    validPlayerPixels = Math.max(validPlayerPixels, 1);
    totalPlayerInk = Math.max(totalPlayerInk, 1);

    // --- CALCULATE SCORE ---

    // 1. Accuracy (Quality of hits)
    let accuracy = matchedScore / validPlayerPixels;

    // 2. Coverage (Did they finish?)
    // FIX: Multiply by 8.0 because player line (6px) is thinner than target (50px)
    // This allows a single trace to count as 100% coverage.
    let coverage = (validPlayerPixels * 8.0) / totalRefPixels;
    coverage = Math.min(coverage, 1.0); 

    // 3. Soft Stray Penalty (Buffer)
    let strayRatio = strayPixels / totalPlayerInk;
    let strayPenalty = 0;
    // Allow 20% messiness for FREE before penalizing
    if (strayRatio > 0.20) {
        strayPenalty = (strayRatio - 0.20) * 0.5;
    }

    // Weighted Final Score
    let scoreRaw = (coverage * 0.6) + (accuracy * 0.4);
    scoreRaw -= strayPenalty;

    // Anti-cheat for empty drawing (<50 pixels)
    if (totalPlayerInk < 50) scoreRaw *= 0.2;

    // Generosity Bonus (Bump B+ to A)
    if (scoreRaw > 0.85) scoreRaw += 0.08;

    scoreRaw = Math.min(Math.max(scoreRaw, 0), 1);
    let score = Math.round(scoreRaw * 100);

    // Feedback
    let msg = score >= 95 ? "ðŸŽ‰ PERFECT!" :
              score >= 80 ? "ðŸ’ª Very good!" :
              score >= 60 ? "ðŸ™‚ Not bad!" :
              "ðŸ˜… Keep trying!";

    scoreBox.textContent = `Score: ${score}% â€” ${msg}`;

    // Show Reference Line
    ctx.globalCompositeOperation = 'destination-over';
    ctx.strokeStyle = '#90EE90';
    ctx.lineWidth = 6;
    drawReference(ctx);
    ctx.globalCompositeOperation = 'source-over';
}

// 2. START GAME (FIXED BUTTON LOGIC)
function startGame() {
    if(timerInterval) clearInterval(timerInterval);
    timerDisplay.textContent="";
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawingEnabled = false;

    // HITBOX (Forgiving - 75px)
    const hitCanvas=document.createElement("canvas");
    hitCanvas.width=canvas.width; hitCanvas.height=canvas.height;
    const hitCtx=hitCanvas.getContext("2d"); hitCtx.lineWidth=75; hitCtx.lineCap="round"; drawReference(hitCtx); 
    hitData=hitCtx.getImageData(0,0,canvas.width,canvas.height).data;

    // EXPECT (Precision - 50px)
    const expectCanvas=document.createElement("canvas");
    expectCanvas.width=canvas.width; expectCanvas.height=canvas.height;
    const expectCtx=expectCanvas.getContext("2d"); expectCtx.lineWidth=50; expectCtx.lineCap="round"; drawReference(expectCtx); 
    expectData=expectCtx.getImageData(0,0,canvas.width,canvas.height).data;

    // SAFE ZONE (Wide - 100px)
    const zoneCanvas=document.createElement("canvas");
    zoneCanvas.width=canvas.width; zoneCanvas.height=canvas.height;
    const zoneCtx=zoneCanvas.getContext("2d"); zoneCtx.lineWidth=100; zoneCtx.lineCap="round"; drawReference(zoneCtx); 
    zoneData=zoneCtx.getImageData(0,0,canvas.width,canvas.height).data;

    // Draw visual guide
    ctx.lineWidth=6; 
    ctx.strokeStyle = '#000000';
    drawReference(ctx);

    setTimeout(()=>{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawingEnabled = true;
        timerDisplay.style.display = "block"; 
        let timeLeft = 25;
        timerDisplay.textContent = `Time left: ${timeLeft}s`;

        timerInterval=setInterval(()=>{
            timeLeft--;
            timerDisplay.textContent=`Time left: ${timeLeft}s`;
            if(timeLeft<=0){
                clearInterval(timerInterval);
                gradeDrawing();
            }
        },1000);

    }, 2000);

    // FIX: Use onclick directly. 
    // Replacing the child node breaks the variable reference for future games.
    finishButton.onclick = gradeDrawing;
}


// ---- Restart ----
restartButton.addEventListener("click", () => {
    if (timerInterval) clearInterval(timerInterval);
    scoreBox.textContent = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    timerDisplay.style.display = "none"; // hide timer immediately
    startGame();
});


startGame();
</script>
</body>
</html>
