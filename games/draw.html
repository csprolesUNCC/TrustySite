<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Stick Figure Grading Game</title>
<style>
    body { 
        background:#f0f0f0; 
        display:flex; 
        flex-direction:column; 
        align-items:center; 
        font-family:Arial, sans-serif;
    }
    canvas {
        background:white;
        border:4px solid black;
        box-shadow:6px 6px 0px #222;
        touch-action:none; /* critical for mobile drawing input */
    }
    button {
        margin-top:15px;
        padding:10px 20px;
        font-size:18px;
        cursor:pointer;
    }
    #scoreBox {
        margin-top:15px;
        font-size:26px;
        font-weight:bold;
    }
    #buttonContainer {
        display: flex;
        justify-content: center; /* center under canvas */
        gap: 10px;               /* space between buttons */
        margin-top: 15px;
    }
</style>
</head>
<body>

<h1>Draw Trusty!</h1>
<canvas id="gameCanvas" width="500" height="500"></canvas>
<div id="scoreBox"></div>
<div id="buttonContainer">
    <button id="finishBtn">DONE</button>
    <button id="restartBtn">RESTART</button>
</div>


<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const finishButton = document.getElementById("finishBtn");
const restartButton = document.getElementById("restartBtn");
const scoreBox = document.getElementById("scoreBox");

let drawing = false;
let lastX = 0, lastY = 0;
let drawingEnabled = false; // prevent drawing until preview ends
let timerInterval = null;
const timerDisplay = document.createElement("div");
timerDisplay.style.fontSize = "22px";
timerDisplay.style.fontWeight = "bold";
timerDisplay.style.marginTop = "10px";
canvas.parentNode.insertBefore(timerDisplay, canvas.nextSibling);

// ---- Draw stick figure reference ----
function drawReference(ctxToDraw) {
    const ctxUse = ctxToDraw;
    ctxUse.strokeStyle = "black";
    ctxUse.lineWidth = 6;

    ctxUse.beginPath();
    ctxUse.ellipse(100, 180, 75, 75 * 1.25, 0, 0, Math.PI * 2);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.ellipse(100, 220, 28, 25 * 1.25, 0, -Math.PI/20, Math.PI + Math.PI/20);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(80, 130); ctxUse.lineTo(80, 180); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(120, 130); ctxUse.lineTo(120, 180); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(100, 275); ctxUse.lineTo(150, 340); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(150, 340); ctxUse.lineTo(425, 340); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(150, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(250, 445); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(300, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(400, 445); ctxUse.stroke();
}

// ---- Player drawing ----
ctx.lineWidth = 5;
ctx.strokeStyle = "black";
ctx.lineCap = "round";

function startDraw(x, y) { if(!drawingEnabled) return; drawing = true; lastX = x; lastY = y; }
function draw(x, y) { if(!drawing || !drawingEnabled) return; ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y;}
function stopDraw() { drawing=false; }

canvas.addEventListener("mousedown", e => startDraw(e.offsetX, e.offsetY));
canvas.addEventListener("mousemove", e => draw(e.offsetX, e.offsetY));
canvas.addEventListener("mouseup", stopDraw);
canvas.addEventListener("mouseenter", e => { lastX = e.offsetX; lastY = e.offsetY; });

canvas.addEventListener("touchstart", e => { const r = canvas.getBoundingClientRect(); const t = e.touches[0]; startDraw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchmove", e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); const t = e.touches[0]; draw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchend", stopDraw);

let hitData, expectData, zoneData;

// ---- Grade drawing ----
// ---- Grade drawing (more generous) ----
function gradeDrawing() {
    drawingEnabled = false;
    timerDisplay.style.display = "none";
    clearInterval(timerInterval);

    const playerPixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;

    let matchedPixels = 0;       // Correct pixels
    let attemptedRefPixels = 0;  // Reference pixels where player tried something
    let totalRefPixels = 0;      // Total reference pixels
    let strayPixels = 0;         // Player pixels outside reference

    for (let i = 3; i < expectData.length; i += 4) {
        if (expectData[i] > 100) totalRefPixels++;
        if (playerPixels[i] > 0 && expectData[i] > 100) {
            matchedPixels++;
            attemptedRefPixels++;
        } else if (playerPixels[i] > 0 && expectData[i] <= 100 && zoneData[i] === 0) {
            strayPixels++;
        } else if (playerPixels[i] > 0 && expectData[i] > 100) {
            attemptedRefPixels++;
        }
    }

    // Prevent divide-by-zero
    totalRefPixels = Math.max(totalRefPixels, 1);
    attemptedRefPixels = Math.max(attemptedRefPixels, 1);

    // Coverage: fraction of reference attempted
    let coverage = attemptedRefPixels / totalRefPixels;

    // Accuracy: fraction of attempted pixels that are correct
    let accuracy = matchedPixels / attemptedRefPixels;

    // Stray penalty
    const totalPlayerPixels = Math.max(
        playerPixels.filter((v, idx) => idx % 4 === 3 && v > 0).length,
        1
    );
    const strayPenalty = Math.min(strayPixels / totalPlayerPixels, 1);

    // Weighted score
    let scoreRaw = coverage * 0.7 + accuracy * 0.3; // coverage matters most
    scoreRaw *= 1 - strayPenalty; // apply stray penalty

    // Punish tiny scribbles
    if (totalPlayerPixels < 20) scoreRaw *= 0.3;
    else if (totalPlayerPixels < 50) scoreRaw *= 0.6;

    // Optional small bonus if coverage is high but accuracy slightly off
    if (coverage > 0.9 && accuracy > 0.8) scoreRaw = Math.min(scoreRaw + 0.05, 1.0);

    let score = Math.round(scoreRaw * 100);

    // Feedback message
    let msg = score >= 95 ? "ðŸŽ‰ PERFECT!" :
              score >= 80 ? "ðŸ’ª Very good!" :
              score >= 60 ? "ðŸ™‚ Not bad!" :
              "ðŸ˜… Keep trying!";

    scoreBox.textContent = `Score: ${score}% â€” ${msg}`;

    // Draw reference behind player's drawing
    ctx.globalCompositeOperation = 'destination-over';
    ctx.strokeStyle = '#90EE90';
    ctx.lineWidth = 6;
    drawReference(ctx);
    ctx.globalCompositeOperation = 'source-over';
}



// ---- Start game ----
function startGame() {
    if(timerInterval) clearInterval(timerInterval);
    timerDisplay.textContent="";
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawingEnabled = false;

    // HITBOX
    const hitCanvas=document.createElement("canvas");
    hitCanvas.width=canvas.width; hitCanvas.height=canvas.height;
    const hitCtx=hitCanvas.getContext("2d"); hitCtx.lineWidth=28; hitCtx.lineCap="round"; drawReference(hitCtx); hitData=hitCtx.getImageData(0,0,canvas.width,canvas.height).data;

    // EXPECT
    const expectCanvas=document.createElement("canvas");
    expectCanvas.width=canvas.width; expectCanvas.height=canvas.height;
    const expectCtx=expectCanvas.getContext("2d"); expectCtx.lineWidth=8; expectCtx.lineCap="round"; drawReference(expectCtx); expectData=expectCtx.getImageData(0,0,canvas.width,canvas.height).data;

    // SAFE ZONE
    const zoneCanvas=document.createElement("canvas");
    zoneCanvas.width=canvas.width; zoneCanvas.height=canvas.height;
    const zoneCtx=zoneCanvas.getContext("2d"); zoneCtx.lineWidth=50; zoneCtx.lineCap="round"; drawReference(zoneCtx); zoneData=zoneCtx.getImageData(0,0,canvas.width,canvas.height).data;

    ctx.lineWidth=6; drawReference(ctx);

    setTimeout(()=>{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        drawingEnabled = true;
        timerDisplay.style.display = "block"; // show timer
        let timeLeft = 25;
        timerDisplay.textContent = `Time left: ${timeLeft}s`;

        timerInterval=setInterval(()=>{
            timeLeft--;
            timerDisplay.textContent=`Time left: ${timeLeft}s`;
            if(timeLeft<=0){
                clearInterval(timerInterval);
                gradeDrawing();
            }
        },1000);

    },2000);

    const newBtn=finishButton.cloneNode(true);
    finishButton.parentNode.replaceChild(newBtn,finishButton);
    newBtn.addEventListener("click",gradeDrawing);
}

// ---- Restart ----
restartButton.addEventListener("click", () => {
    if (timerInterval) clearInterval(timerInterval);
    scoreBox.textContent = "";
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    timerDisplay.style.display = "none"; // hide timer immediately
    startGame();
});


startGame();
</script>
</body>
</html>
