<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Draw Trusty! - Trusty da Horse</title>
<link rel="apple-touch-icon" sizes="180x180" href="../images/mobile-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="../images/icon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="../images/icon-16x16.png">
<link rel="stylesheet" href="../styles/stylesheet.css">
<script> window.va = window.va || function () { (window.vaq = window.vaq || []).push(arguments); }; </script>
<script defer src="/_vercel/insights/script.js"></script>
<style>
    /* New styles for comic-style integration */
    .content {
        display: flex; /* Allow content to align canvas */
        flex-direction: column;
        align-items: center;
        text-align: center;
    }
    
    canvas {
        background:white;
        /* Updated border and shadow to match the comic style */
        border: 3px solid #111; 
        box-shadow: 6px 6px 0px 0px #111;
        touch-action:none; /* critical for mobile drawing input */
    }
    button {
        margin-top:15px;
        padding:10px 20px;
        font-size:18px;
        cursor:pointer;
        /* Button style matching other Trusty elements */
        border: 2px solid #111;
        background-color: #ffe08d;
        font-weight: bold;
        box-shadow: 3px 3px 0px 0px #555;
        border-radius: 0;
        transition: all 0.1s;
    }
    button:active {
        box-shadow: 1px 1px 0px 0px #555;
        transform: translate(2px, 2px);
    }
    #scoreBox {
        margin-top:15px;
        font-size:26px;
        font-weight:bold;
    }
    #buttonContainer {
        display: flex;
        justify-content: center; /* center under canvas */
        gap: 10px;               /* space between buttons */
        margin-top: 15px;
    }
    /* Style for the timer text */
    #gameCanvas + div { /* Selects the div immediately after the canvas (the timer) */
        font-size: 22px;
        font-weight: bold;
        margin-top: 10px;
    }
</style>
</head>
<body>

    <header>
        <h1>Draw Trusty!</h1>
        <div id="auth-component-placeholder">
            </div>
    </header>

    <nav id="navbar-placeholder"></nav>

    <div class="content">
        <h2>Memorize and Draw!</h2>
        
        <canvas id="gameCanvas" width="500" height="500"></canvas>
        <div id="scoreBox"></div>
        <div id="buttonContainer">
            <button id="finishBtn">DONE</button>
            <button id="restartBtn">RESTART</button>
        </div>
    </div>


    <footer><p id="footer-placeholder"></p></footer>
    
    <script src="../scripts/componentLoader.js"></script>
    <script src="/scripts/loginHandler.js"></script>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const finishButton = document.getElementById("finishBtn");
const restartButton = document.getElementById("restartBtn");
const scoreBox = document.getElementById("scoreBox");

let drawing = false;
let gameFinished = false;
let lastX = 0, lastY = 0;
let drawingEnabled = false; // prevent drawing until preview ends
let timerInterval = null;
let startTimeout = null;
const timerDisplay = document.createElement("div");
timerDisplay.style.fontSize = "22px";
timerDisplay.style.fontWeight = "bold";
timerDisplay.style.marginTop = "10px";
canvas.parentNode.insertBefore(timerDisplay, canvas.nextSibling);

// ---- Draw stick figure reference ----
function drawReference(ctxToDraw) {
    const ctxUse = ctxToDraw;
    ctxUse.strokeStyle = "black";

    ctxUse.beginPath();
    ctxUse.ellipse(100, 180, 75, 75 * 1.25, 0, 0, Math.PI * 2);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.ellipse(100, 220, 28, 25 * 1.25, 0, -Math.PI/20, Math.PI + Math.PI/20);
    ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(80, 130); ctxUse.lineTo(80, 180); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(120, 130); ctxUse.lineTo(120, 180); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(100, 275); ctxUse.lineTo(150, 340); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(150, 340); ctxUse.lineTo(425, 340); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(150, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(200, 345); ctxUse.lineTo(250, 445); ctxUse.stroke();

    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(300, 445); ctxUse.stroke();
    ctxUse.beginPath();
    ctxUse.moveTo(350, 345); ctxUse.lineTo(400, 445); ctxUse.stroke();
}

// ---- Player drawing ----
ctx.lineWidth = 5;
ctx.strokeStyle = "black";
ctx.lineCap = "round";

function startDraw(x, y) { if(!drawingEnabled) return; drawing = true; lastX = x; lastY = y; }
function draw(x, y) { if(!drawing || !drawingEnabled) return; ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke(); lastX=x; lastY=y;}
function stopDraw() { drawing=false; }

canvas.addEventListener("mousedown", e => startDraw(e.offsetX, e.offsetY));
canvas.addEventListener("mousemove", e => draw(e.offsetX, e.offsetY));
canvas.addEventListener("mouseup", stopDraw);
canvas.addEventListener("mouseenter", e => { lastX = e.offsetX; lastY = e.offsetY; });

canvas.addEventListener("touchstart", e => { const r = canvas.getBoundingClientRect(); const t = e.touches[0]; startDraw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchmove", e => { e.preventDefault(); const r = canvas.getBoundingClientRect(); const t = e.touches[0]; draw(t.clientX - r.left, t.clientY - r.top); });
canvas.addEventListener("touchend", stopDraw);

let hitData, expectData, closeData, zoneData;

function gradeDrawing() {
    if (!drawingEnabled && !gameFinished) return; // prevent scoring w/ reference image
    if (gameFinished) return; // Prevent scoring twice

    resetGameState();
    gameFinished = true;

    drawingEnabled = false;
    timerDisplay.style.display = "none";
    clearInterval(timerInterval);

    const width = canvas.width;
    const height = canvas.height;

    // 1. Get User Data (The raw pixel array from the screen)
    const userImgData = ctx.getImageData(0, 0, width, height).data;

    // 2. Get Reference Data (The ghost canvas)
    // We pass '25' as the lineWidth to create a thick "Tolerance Zone" or Hitbox.
    // If the user's line touches anywhere inside this thick invisible line, it counts.
    const perfectCanvas = getGhostCanvas(6);
    const perfectCtx = perfectCanvas.getContext('2d');
    const perfectImgData = perfectCtx.getImageData(0, 0, width, height).data;
    
    const ghostCanvas = getGhostCanvas(25);
    const ghostCtx = ghostCanvas.getContext('2d');
    const ghostImgData = ghostCtx.getImageData(0, 0, width, height).data;

    const ghostCanvas2 = getGhostCanvas(50);
    const ghostCtx2 = ghostCanvas2.getContext('2d');
    const ghostImgData2 = ghostCtx2.getImageData(0, 0, width, height).data;

    const ghostCanvas3 = getGhostCanvas(70);
    const ghostCtx3 = ghostCanvas3.getContext('2d');
    const ghostImgData3 = ghostCtx3.getImageData(0, 0, width, height).data;

    const ghostCanvas4 = getGhostCanvas(140);
    const ghostCtx4 = ghostCanvas4.getContext('2d');
    const ghostImgData4 = ghostCtx4.getImageData(0, 0, width, height).data;



    let overlapCount = 0;
    let totalUserPixels = 0;

    let perfectUserPixels = 0;
    let totalRefPixels = 0;

    // 3. The Comparison Loop
    // The data array is a long list of [Red, Green, Blue, Alpha, Red, Green, Blue, Alpha...]
    // We step by 4 to look at each pixel one by one.
    for (let i = 0; i < userImgData.length; i += 4) {
        
        // We look at index + 3, which is the Alpha (transparency) channel.
        const userAlpha = userImgData[i + 3];
        const perfectAlpha = perfectImgData[i + 3];
        const ghostAlpha = ghostImgData[i + 3];
        const ghostAlpha2 = ghostImgData2[i + 3];
        const ghostAlpha3 = ghostImgData3[i + 3];
        const ghostAlpha4 = ghostImgData4[i + 3];

        // completeness logic
        if (perfectAlpha > 50) {
            totalRefPixels++; // count pixels in the perfect one!
            if (userAlpha > 50){
                perfectUserPixels++;
            }

        }

        // precision logic
        // CHECK 1: Did the user draw here?
        // We set threshold > 100 to ignore the faint gray guide lines 
        // and only count the dark black ink the user drew.

        // CHECK 2: Is this pixel inside the Reference Hitbox?

        if (userAlpha > 100) {
            totalUserPixels++; // Count total amount of ink used
            if (perfectAlpha > 50) {
                overlapCount=overlapCount+1.05; // Count how much of that ink is "Correct"
            }
            else if (ghostAlpha > 50) {
                overlapCount=overlapCount+0.9; // Count how much of that ink is "Correct"
            }
            else if (ghostAlpha2 > 50) {
                overlapCount=overlapCount+0.8; // Count how much of that ink is "Correct"
            }
            else if (ghostAlpha3 > 50) {
                overlapCount=overlapCount+0.7; // Count how much of that ink is "Correct"
            }
            else if (ghostAlpha4 > 50) {
                overlapCount=overlapCount+0.5; // Count how much of that ink is "Correct"
            }
            else{
                overlapCount=overlapCount-1.5;
            }
        }
    }





    // --- CALCULATE SCORE ---
    let precision = 0;
    if (totalUserPixels > 0) {
        precision = (overlapCount / totalUserPixels);
    }
    if (precision > 1) precision = 1;

    // COMPLETENESS: Did you draw the whole figure? 
    // We compare user's correct pixels against the reference's total pixels.
    // We cap this at 1.0 so drawing EXTRA ink doesn't give > 100%
    let completeness = 0;
    if (totalRefPixels > 0) {
        completeness = (perfectUserPixels / totalRefPixels) * 3;
    }
    if (completeness > 1) completeness = 1;

    // FINAL MIX: 50% precision, 50% Completeness
    // This rewards neat lines AND finishing the drawing.
    let finalScoreRaw = (precision * 0.5) + (completeness * 0.5);


    // too much ink penalty
    let inkRatio = 0;
    if (totalRefPixels > 0) {
        inkRatio = totalUserPixels / totalRefPixels;
    }

    // Set a threshold. 
    // If the user uses 5x more pixels than the reference, that's fine (normal brush).
    // If they go above 5x, we start penalizing.
    const maxAllowedRatio = 1.3; 
    let thicknessPenalty = 1.0; // Default: No penalty (100% of score)

    if (inkRatio > maxAllowedRatio) {
        // The penalty gets harsher the more they scribble.
        // Example: If ratio is 10.0, penalty becomes (5 / 10) = 0.5. Score is cut in half.
        thicknessPenalty = maxAllowedRatio / inkRatio;
    }

    // Apply the penalty
    finalScoreRaw = finalScoreRaw * thicknessPenalty;
    let finalScore = Math.floor(finalScoreRaw * 100);

    if (finalScore < 0) finalScore = 0;
    const msg = finalScore === 100 ? "ðŸŽ‰ PERFECT!" : "";

    scoreBox.textContent = `Score: ${finalScore}% ${msg}`;

    // --- SHOW FINAL REFERENCE LINE ---
    ctx.globalCompositeOperation = 'destination-over';
    ctx.strokeStyle = '#90EE90';
    ctx.lineWidth = 6;
    drawReference(ctx);
    ctx.globalCompositeOperation = 'source-over';
}

function resetGameState() {
    gameFinished = false;
    if (timerInterval) clearInterval(timerInterval);
    if (startTimeout) clearTimeout(startTimeout); // Stops the pending game start
    timerInterval = null;
    startTimeout = null;
    drawingEnabled = false;
}


function startGame() {
    // 1. Kill any existing timers or pending starts immediately
    resetGameState();
    timerDisplay.style.display = "block"; 
    timerDisplay.textContent = "Memorize Trusty!";
    scoreBox.textContent = "";
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.lineWidth = 6; 
    ctx.strokeStyle = '#000000';
    drawReference(ctx);

    // 2. Assign the timeout to the variable so we can cancel it if needed
    startTimeout = setTimeout(() => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Reset styles for user drawing (Important because drawReference changed them)
        ctx.lineWidth = 5;
        ctx.strokeStyle = "black";
        ctx.lineCap = "round";

        drawingEnabled = true;
        timerDisplay.style.display = "block"; 
        let timeLeft = 25;
        timerDisplay.textContent = `Time left: ${timeLeft}s`;

        timerInterval = setInterval(() => {
            timeLeft--;
            timerDisplay.textContent = `Time left: ${timeLeft}s`;
            if (timeLeft <= 0) {
                //resetGameState(); // Stop timers
                gradeDrawing();
            }
        }, 1000);

    }, 2000);
}


// THIS LINE WAS MISSING:
finishButton.addEventListener("click", gradeDrawing);

// ---- Restart ----
restartButton.addEventListener("click", startGame);








// making grading layers
function getGhostCanvas(lineWidth) {
    // 1. Create an off-screen canvas
    const canvas = document.createElement('canvas');
    canvas.width = 500;
    canvas.height = 500;
    const ctx = canvas.getContext('2d');

    // 2. Set the style
    ctx.lineWidth = lineWidth;
    ctx.strokeStyle = "black";
    ctx.lineCap = "round"; // Important for smooth joints
    ctx.lineJoin = "round";

    // 3. Draw the Shape (Exact coordinates from your original code)
    
    // -- Head --
    ctx.beginPath();
    ctx.ellipse(100, 180, 75, 75 * 1.25, 0, 0, Math.PI * 2);
    ctx.stroke();

    // -- Mouth --
    ctx.beginPath();
    ctx.ellipse(100, 220, 28, 25 * 1.25, 0, -Math.PI/20, Math.PI + Math.PI/20);
    ctx.stroke();

    // -- Eyes --
    ctx.beginPath();
    ctx.moveTo(80, 130); ctx.lineTo(80, 180);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(120, 130); ctx.lineTo(120, 180);
    ctx.stroke();

    // -- Neck/Body connector --
    ctx.beginPath();
    ctx.moveTo(100, 275); ctx.lineTo(150, 340);
    ctx.stroke();

    // -- Long Back --
    ctx.beginPath();
    ctx.moveTo(150, 340); ctx.lineTo(425, 340);
    ctx.stroke();

    // -- Front Legs --
    ctx.beginPath();
    ctx.moveTo(200, 345); ctx.lineTo(150, 445);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(200, 345); ctx.lineTo(250, 445);
    ctx.stroke();

    // -- Back Legs --
    ctx.beginPath();
    ctx.moveTo(350, 345); ctx.lineTo(300, 445);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(350, 345); ctx.lineTo(400, 445);
    ctx.stroke();

    return canvas;
}



























startGame();
</script>
</body>
</html>
